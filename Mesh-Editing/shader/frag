uniform int outputID;
uniform vec3 eyePos;
varying vec3 normal;
varying vec3 vertex;

#define PI 3.1415926

vec3 shadeDiffuseFromEye();

vec3 shadePhong(vec3 lightPos);

vec3 shadeEnvmapReflection();

void main()
{
    if(outputID == 0)
    {
        gl_FragColor = vec4(shadeDiffuseFromEye(), 1.0);
        return;
    }
    if(outputID == 1)
    {
        gl_FragColor = vec4(shadePhong(vec3(10, 10, 10)), 1.0);
        return;
    }
    if(outputID == 2)
    {
        // Do something interesting here for extra credit.
        gl_FragColor = vec4(shadePhong(vec3(10, 100, 10)), 1.0);
        return;
    }
}

vec3 shadeDiffuseFromEye()
{
    vec3 n = normalize(normal);
    vec3 out_vec = normalize(eyePos - vertex);
    float diffuse = abs(dot(out_vec, n));
    return vec3(diffuse);
}

vec3 shadePhong(vec3 lightPos)
{
    // TODO Part 7.
    // TODO Compute Phong shading here. You can choose any color you like. But make
    // TODO sure that you have noticeable specular highlights in the shading.
    // TODO Variables to use: eyePos, lightPos, normal, vertex

    // calculate diffuse and specular lighting values for each fragment 
    vec3 color = vec3(255.0/255.0, 87.0/255.0, 51.0/255.0);
    float p = 16.0; //specular exponent
    vec3 l = normalize(lightPos - vertex); //l = light direction (normalized light vector)
    vec3 v = normalize(eyePos - vertex); //v = viewer direction (camera vector, current frag to camera)
    vec3 n = normalize(normal); //n = fragment normal
    
    const vec3 La = vec3(0.1, 0.1, 0.1); //ambient color of fragment
    const float MAX_DIST = 2.5;
    const float MAX_DIST_SQUARED = MAX_DIST * MAX_DIST;
    float distFactor = 1.0 - (1.0/MAX_DIST_SQUARED);

    //light falloff 1/R^2, no distance factor here since only 1 light source
    float diffuseDot = dot(n, l); //cos(theta)
    vec3 kd = color;
    vec3 Ld = kd * clamp(diffuseDot, 0.0, 1.0) * distFactor;

    vec3 h = normalize(v + l); //halfangle vector close to normal, bivector of v and l
    vec3 ks = min(color + 0.5, 1.0); //smallest from white or current color+0.5
    float specularDot = dot(n, h); //cos(alpha)
    vec3 Ls = ks * pow(max(0.0, clamp(specularDot, 0.0, 1.0)), p) * distFactor; //specular compoennt
    
    return (La + Ld + Ls); //blinn-phong model
}
